<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blockfront historical</title>
    <link type="text/css" rel="stylesheet" href="{{url_for('static', filename='css/master.css')}}"/>
    <link type="text/css" rel="stylesheet" href="{{url_for('static', filename='css/index.css')}}"/>
    <style>
        html {
            color: white;
            background-color: black;
        }
        /* Chart container + tooltip */
        #myplot { position: relative; }
        .tooltip {
        position: absolute;
        pointer-events: none;
        background: rgba(0,0,0,0.85);
        color: #fff;
        padding: 6px 8px;
        border-radius: 4px;
        font-size: 12px;
        display: none;
        box-shadow: 0 0 6px rgba(255,255,255,0.04);
        white-space: nowrap;
        font-family: Arial, Helvetica, sans-serif;
        }
        .line { fill: none; stroke-width: 1.5px; }
        .legend {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin-bottom: 10px;
            font-family: sans-serif;
            color: white;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 14px;
            cursor: default;
        }
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }
        .tooltip {
        position: absolute;
        background: rgba(10, 10, 10, 0.9);
        border: 1px solid #555; 
        padding: 10px;
        color: white;
        pointer-events: none;
        font-size: 13px;
        border-radius: 4px;
        z-index: 100; 
        line-height: 1.4;
        }
    </style>
</head>
<body>
    {% include 'nav.html' %}
    <main>
        <h2 style="text-align: center;">Player Stats Historical Data</h2>
        <div id="myplot"></div>
    </main>

<script type="module">
import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

// raw data injected by server
const raw = {{ raw_data | safe }};

// parse data and normalize numeric fields
raw.forEach(d => {
  d.date = new Date(d.Date + "Z"); // Parse UTC date
  d.Kills = +d.Kills;
  d.Deaths = +d.Deaths;
  d.Assists = +d.Assists;
  d.Headshots = +d.Headshots;
  d.Wins = +d.Wins;
  d.Games = +d.Games;
});

// Defining the tracked keys for player stats
const keys = ["Kills", "Deaths", "Assists", "Headshots", "Wins", "Games"];
const series = keys.map(k => ({ id: k, values: raw.map(d => ({date: d.date, value: d[k]})) }));

// dimensions
const margin = {top: 20, right: 20, bottom: 30, left: 50};
const container = document.querySelector('#myplot');
container.innerHTML = '';
const width = Math.max(700, container.clientWidth || 900) - margin.left - margin.right;
const height = 400 - margin.top - margin.bottom;

const svg = d3.select('#myplot')
  .append('svg')
  .attr('width', width + margin.left + margin.right)
  .attr('height', height + margin.top + margin.bottom)
  .style('background', 'black')
  .append('g')
  .attr('transform', `translate(${margin.left},${margin.top})`);

// full data bounds
const minDate = d3.min(raw, d => d.date);
const maxDate = d3.max(raw, d => d.date);

// Display the last 30 days by default (or max if fewer)
const defaultPastDate = d3.timeDay.offset(maxDate, -30);
const startDate = minDate > defaultPastDate ? minDate : defaultPastDate;

const x = d3.scaleTime()
  .domain([startDate, maxDate]) 
  .range([0, width]);

// y domain across all series
const yMax = d3.max(raw, d => Math.max(d.Kills, d.Deaths, d.Assists, d.Headshots, d.Wins, d.Games));
const y = d3.scaleLinear()
  .domain([0, yMax])
  .nice()
  .range([height, 0]);

const color = d3.scaleOrdinal(d3.schemeCategory10).domain(keys);

// axes
const xAxisG = svg.append('g')
  .attr('transform', `translate(0,${height})`)
  .attr('class','x-axis')
  .call(d3.axisBottom(x).ticks(width / 80))
  .selectAll('text').style('fill','white');
const yAxisG = svg.append('g')
  .attr('class','y-axis')
  .call(d3.axisLeft(y))
  .selectAll('text').style('fill','white');

// line generator
const lineGen = d3.line()
  .x(d => x(d.date))
  .y(d => y(d.value))
  .curve(d3.curveMonotoneX);

// clipping
svg.append('clipPath').attr('id','clip').append('rect').attr('width', width).attr('height', height);

const linesG = svg.append('g').attr('clip-path','url(#clip)');

linesG.selectAll('path')
  .data(series)
  .enter()
  .append('path')
  .attr('class','line')
  .attr('d', d => lineGen(d.values))
  .style('stroke', d => color(d.id))
  .style('fill','none');

// overlay for pointer & zoom
const overlay = svg.append('rect')
  .attr('width', width)
  .attr('height', height)
  .style('fill','none')
  .style('pointer-events','all');

const focus = svg.append('g').style('display', 'none');

// Vertical line
focus.append('line')
  .attr('class', 'vline')
  .attr('y1', 0)
  .attr('y2', height)
  .style('stroke', '#fff')
  .style('stroke-opacity', 0.5);

// Add a circle for each data series
const circles = focus.selectAll('.focus-circle')
  .data(keys)
  .enter()
  .append('circle')
  .attr('class', 'focus-circle')
  .attr('r', 4)
  .style('fill', d => color(d))
  .style('stroke', 'white')
  .style('stroke-width', 1);

const tooltip = d3.select('#myplot').append('div').attr('class','tooltip');

const bisectDate = d3.bisector(d => d.date).left;

const zoom = d3.zoom().extent([[0,0],[width,height]]).on('zoom', zoomed);
overlay.call(zoom);

overlay.on('dblclick', () => {
  overlay.transition().duration(600).call(zoom.transform, d3.zoomIdentity);
});

// zoom handler
function zoomed(event) {
  const t = event.transform;
  let newX = t.rescaleX(x);

  let dom = newX.domain();
  let clamped = false;
  if (dom[0] < minDate) { const delta = minDate - dom[0]; dom[0] = minDate; dom[1] = new Date(dom[1].getTime() + delta); clamped = true; }
  if (dom[1] > maxDate) { const delta = dom[1] - maxDate; dom[1] = maxDate; dom[0] = new Date(dom[0].getTime() - delta); clamped = true; }

  const useX = clamped ? d3.scaleTime().domain(dom).range([0, width]) : newX;

  svg.select('.x-axis').call(d3.axisBottom(useX).ticks(width / 80));
  linesG.selectAll('.line').attr('d', d => d3.line().x(d2 => useX(d2.date)).y(d2 => y(d2.value))(d.values));
}

// Create Legend Container
const legendContainer = d3.select('#myplot')
  .insert('div', 'svg') 
  .attr('class', 'legend');

keys.forEach(key => {
  const item = legendContainer.append('div').attr('class', 'legend-item');
  
  item.append('div')
    .attr('class', 'legend-color')
    .style('background-color', color(key));
    
  item.append('span').text(key);
});

// pointer interactions
overlay
  .on('mouseover', () => { 
      focus.style('display', null); 
      tooltip.style('display', 'block'); 
  })
  .on('mouseout', () => { 
      focus.style('display', 'none'); 
      tooltip.style('display', 'none'); 
  })
  .on('mousemove', (event) => {
      const transform = d3.zoomTransform(overlay.node());
      const currX = transform.rescaleX(x);

      const [mx] = d3.pointer(event);
      const x0 = currX.invert(mx);
      
      const i = bisectDate(raw, x0);
      const d0 = raw[i-1] || raw[i];
      if (!d0) return;

      const px = currX(d0.date);
      focus.attr('transform', `translate(${px},0)`);

      circles.attr('cy', key => y(d0[key])); 

      tooltip.html(`<strong>${d0.date.toLocaleString()}</strong><br/>` + 
          keys.map(k => `<span style="color:${color(k)}">‚óè</span> ${k}: ${d0[k]}`).join('<br/>'))
        .style('left', (event.pageX + 15) + 'px')
        .style('top', (event.pageY - 28) + 'px');
  });

</script>
</body>
</html>