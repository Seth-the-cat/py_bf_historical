<!DOCTYPE html>
<style>
    html {
        color: white;
        background-color: black;
    }
    /* Chart container + tooltip */
    #myplot { position: relative; }
    .tooltip {
      position: absolute;
      pointer-events: none;
      background: rgba(0,0,0,0.85);
      color: #fff;
      padding: 6px 8px;
      border-radius: 4px;
      font-size: 12px;
      display: none;
      box-shadow: 0 0 6px rgba(255,255,255,0.04);
      white-space: nowrap;
      font-family: Arial, Helvetica, sans-serif;
    }
    .line { fill: none; stroke-width: 1.5px; }
    .legend {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 15px;
    margin-bottom: 10px;
    font-family: sans-serif;
    color: white;
    }
    .legend-item {
        display: flex;
        align-items: center;
        gap: 5px;
        font-size: 14px;
        cursor: default;
    }
    .legend-color {
        width: 12px;
        height: 12px;
        border-radius: 2px;
    }
    /* Style for your D3 tooltip which might be invisible right now */
    .tooltip {
        position: absolute;
        background: rgba(0, 0, 0, 0.85);
        border: 1px solid #444;
        padding: 8px;
        color: white;
        pointer-events: none;
        font-size: 12px;
        border-radius: 4px;
        z-index: 10;
    }
    .tooltip {
      position: absolute;
      background: rgba(10, 10, 10, 0.9);
      border: 1px solid #555; /* Adds a subtle border */
      padding: 10px;
      color: white;
      pointer-events: none;
      font-size: 13px;
      border-radius: 4px;
      z-index: 100; /* Ensures it stays on top of the legend */
      line-height: 1.4;
    }
</style>

<div id="myplot"></div>
<script type="module">

import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

// raw data injected by server
const raw = {{raw_data | safe}};


// parse data and normalize numeric fields
raw.forEach(d => {
  d.date = new Date(d.Date + "Z");
  d.Players = +d.Players;
  d.Dom = +d.Dom;
  d.TDM = +d.TDM;
  d.Inf = +d.Inf;
  d.GG = +d.GG;
  d.TTT = +d.TTT;
  d.Boot = +d.Boot;
});

const keys = ["Players","Dom","TDM","Inf","GG","TTT","Boot"];
const series = keys.map(k => ({ id: k, values: raw.map(d => ({date: d.date, value: d[k]})) }));

// dimensions
const margin = {top: 20, right: 20, bottom: 30, left: 50};
const container = document.querySelector('#myplot');
container.innerHTML = '';
const width = Math.max(700, container.clientWidth || 900) - margin.left - margin.right;
const height = 400 - margin.top - margin.bottom;

const svg = d3.select('#myplot')
  .append('svg')
  .attr('width', width + margin.left + margin.right)
  .attr('height', height + margin.top + margin.bottom)
  .style('background', 'black')
  .append('g')
  .attr('transform', `translate(${margin.left},${margin.top})`);

// x domain: initial view is last 24 hours
const now = new Date();
const oneDayAgo = new Date(now.getTime() - 24*60*60*1000);

// full data bounds
const minDate = d3.min(raw, d => d.date);
const maxDate = d3.max(raw, d => d.date);


const x = d3.scaleTime()
  .domain([d3.timeHour.offset(maxDate, -24), maxDate]) // Subtracts 24 hours from maxDate
  .range([0, width]);

// y domain across all series
const yMax = d3.max(raw, d => Math.max(d.Players, d.Dom, d.TDM, d.Inf, d.GG, d.TTT, d.Boot));
const y = d3.scaleLinear()
  .domain([0, yMax])
  .nice()
  .range([height, 0]);

const color = d3.scaleOrdinal(d3.schemeCategory10).domain(keys);

// axes
const xAxisG = svg.append('g')
  .attr('transform', `translate(0,${height})`)
  .attr('class','x-axis')
  // FIX: Remove .ticks(d3.timeHour.every(2)) and .tickFormat(...)
  // width / 80 tells D3 to place a tick roughly every 80 pixels, preventing overlap
  .call(d3.axisBottom(x).ticks(width / 80))
  .selectAll('text').style('fill','white');
const yAxisG = svg.append('g')
  .attr('class','y-axis')
  .call(d3.axisLeft(y))
  .selectAll('text').style('fill','white');

// line generator
const lineGen = d3.line()
  .x(d => x(d.date))
  .y(d => y(d.value))
  .curve(d3.curveMonotoneX);

// clipping
svg.append('clipPath').attr('id','clip').append('rect').attr('width', width).attr('height', height);

const linesG = svg.append('g').attr('clip-path','url(#clip)');

linesG.selectAll('path')
  .data(series)
  .enter()
  .append('path')
  .attr('class','line')
  .attr('d', d => lineGen(d.values))
  .style('stroke', d => color(d.id))
  .style('fill','none');

// overlay for pointer & zoom
const overlay = svg.append('rect')
  .attr('width', width)
  .attr('height', height)
  .style('fill','none')
  .style('pointer-events','all');

// tooltip + vertical line
// --- Update the 'focus' group setup ---
const focus = svg.append('g').style('display', 'none');

// Existing vertical line
focus.append('line')
  .attr('class', 'vline')
  .attr('y1', 0)
  .attr('y2', height)
  .style('stroke', '#fff')
  .style('stroke-opacity', 0.5);

// NEW: Add a circle for each data series
const circles = focus.selectAll('.focus-circle')
  .data(keys)
  .enter()
  .append('circle')
  .attr('class', 'focus-circle')
  .attr('r', 4) // Size of the dot
  .style('fill', d => color(d)) // Match line color
  .style('stroke', 'white')
  .style('stroke-width', 1);
const tooltip = d3.select('#myplot').append('div').attr('class','tooltip');

const bisectDate = d3.bisector(d => d.date).left;

// compute pixel x positions for full data range (for translateExtent)
const minXpix = x(minDate);
const maxXpix = x(maxDate);

const zoom = d3.zoom().extent([[0,0],[width,height]]).on('zoom', zoomed);

// const zoom = d3.zoom()
//   .scaleExtent([1, 50])
//   .translateExtent([[Math.min(minXpix - width, -1e6), -Infinity], [Math.max(maxXpix + width, 1e6), Infinity]])
//   .extent([[0,0],[width,height]])
//   .on('zoom', zoomed);

overlay.call(zoom);

// dblclick to reset to initial 24h view
overlay.on('dblclick', () => {
  overlay.transition().duration(600).call(zoom.transform, d3.zoomIdentity);
});

// zoom handler
function zoomed(event) {
  const t = event.transform;
  let newX = t.rescaleX(x);

  // clamp domain to available data range
  let dom = newX.domain();
  let clamped = false;
  if (dom[0] < minDate) { const delta = minDate - dom[0]; dom[0] = minDate; dom[1] = new Date(dom[1].getTime() + delta); clamped = true; }
  if (dom[1] > maxDate) { const delta = dom[1] - maxDate; dom[1] = maxDate; dom[0] = new Date(dom[0].getTime() - delta); clamped = true; }

  const useX = clamped ? d3.scaleTime().domain(dom).range([0, width]) : newX;

  // update axis and lines
  // FIX: Use the same dynamic tick count here. 
  // We also removed the forced timeFormat so D3 will automatically show dates (Jan 1) when zoomed out, 
  // and times (12:00) when zoomed in.
  svg.select('.x-axis').call(d3.axisBottom(useX).ticks(width / 80));
  
  linesG.selectAll('.line').attr('d', d => d3.line().x(d2 => useX(d2.date)).y(d2 => y(d2.value))(d.values));
}

// Create Legend Container
const legendContainer = d3.select('#myplot')
  .insert('div', 'svg') // Put it before the SVG
  .attr('class', 'legend');

// Add items to legend based on your 'keys' array
keys.forEach(key => {
  const item = legendContainer.append('div').attr('class', 'legend-item');
  
  item.append('div')
    .attr('class', 'legend-color')
    .style('background-color', color(key));
    
  item.append('span').text(key);
});

// pointer interactions
overlay
  .on('mouseover', () => { 
      focus.style('display', null); 
      tooltip.style('display', 'block'); 
  })
  .on('mouseout', () => { 
      focus.style('display', 'none'); 
      tooltip.style('display', 'none'); 
  })
  .on('mousemove', (event) => {
      const transform = d3.zoomTransform(overlay.node());
      const currX = transform.rescaleX(x);

      const [mx] = d3.pointer(event);
      const x0 = currX.invert(mx);
      
      // Find the data point closest to the mouse
      const i = bisectDate(raw, x0);
      const d0 = raw[i-1] || raw[i];
      if (!d0) return;

      const px = currX(d0.date);
      focus.attr('transform', `translate(${px},0)`);

      // Position each dot on its respective line
      circles.attr('cy', key => y(d0[key])); 

      // Update tooltip content and position
      tooltip.html(`<strong>${d0.date.toLocaleString()}</strong><br/>` + 
          keys.map(k => `<span style="color:${color(k)}">‚óè</span> ${k}: ${d0[k]}`).join('<br/>'))
        .style('left', (event.pageX + 15) + 'px')
        .style('top', (event.pageY - 28) + 'px');
  });

</script>